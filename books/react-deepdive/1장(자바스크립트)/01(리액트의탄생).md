# [스터디] 리액트 딥다이브 -1

## 왜 리액트인가?

2011년 페이스북의 뉴스피드 페이지에서 처음 선보인 리액트는 출시된 지 10년이 넘은. 제법 프런트엔드 생태계에서 오랜 명맥을 이어가는 라이브러리로 자리 잡았다. 채용시장에서 ‘프런트엔드 개발자’ 포지션을 살펴보면 대부분 리액트에 대한 개발 경험을 요구하고 있어 리액트가 프런트엔드 개발자에게 필수적인 기술로 자리 잡은 것을 어림짐작할 수 있다.

그리고 놀라운 사실 중 하나는 얼마 전 리액트가 전자정부 표준 프레임워크의 프런트엔드 개발 도구로 채택됐다는 것이다.

끝나지 않을 것 같은 제이쿼리의 아성을 2018년을 기점으로 리액트가 무너뜨렸으며, 2024년 현재도 그러한 기세는 당분간 식지 않을 것으로 보인다.

### 리액트를 선호하는 이유

1. 리액트는 단방향 바인딩만 지원한다.
2. 양방향 바인딩으로 바인딩되면 뷰의 변화가 컴포넌트에 영향을 미칠 수도, 반대로 컴포넌트의 상태가 변경되면 뷰의 상태도 변할 수 있다. 그래서 규모가 커질 수록 무엇으로 상태가 변했는지 알 수 없다.
3. 리액트의 명시적인 상태 업데이트는 많은 개발자들에게 간단함과 유연함을 제공한다.
4. JSX(javascript XML) 을 사용해서 기존에 알고 있는 자바스크립트 문법에 html을 약간 가미한 수준이며, 고유의 몇가지 특징만 이해한다면 손쉽게 JSX 코드를 구현할 수 있다.
5. 리액트는 단순히 UI를 위한 라이브러리로만 작동함으로써 그 역할에 제한을 두고 그 외의 모든 것에 자유도를 두었다. 개발자들은 리액트를 기반으로 다양한 것을 시도해 볼 수 있었고 그만큼 리액트는 커다란 커뮤니티를 얻을 수 있게 됐다. 그리고 특히 커뮤니티가 강력하다.

## 리액트의 역사

누군가 리액트의 탄생부터 지금까지 역사에 대해 물어본다면 이에 대해 제대로 답할 수 있는 개발자는 별로 없을 것이다. 대부분의 개발자가 리액트를 본격적으로 접하기 시작한 것은 리액트 16.8.0 버전에서 훅이 처음 선보이면서 많은 인기를 끌던 시점으로, 클래스 컴포넌트 조차 생소한 사람이 대부분이기 때문이다. 대다수의 프론트엔드 개발자에게 리액트에 대해 물어본다면 현재는 메타로 사명을 바꾼 페이스북이 만들었고, 16 버전부터 현재는 18버전까지 나온 프론트엔드에서 가장 널리 사용되는 프레임워크라는 점 정도만 이야기할 수 있을 것이다.

### 2010년대 프런트엔드 개발 환경을 향한 페이스북의 도전

2000년대 까지만 하더라도 웹 생태계는 이른바 LAMP 스택이라고 하는 리눅스, 아파치, 웹서버, MySQL, PHP를 활용한 웹 개발이 주를 이루던 시기였다. 이러한 웹 개발 패턴은 사용하는 프레임워크에 따라 조금씩 다르지만 대부분 데이터베이스에서 필요한 데이터를 불러온 다음, 웹 서버에서 HTML 페이지를 만들어서 클라이언트에 제공하는 방식으로 작동한다.

이렇게 서버에서 만든 HTML 페이지를 수동적으로 보여주던 프론트엔드의 역할은 2010년대에 들어서면서 조금씩 변하기 시작했다. 자바스크립트를 좀 더 편히라게 사용하기 위한 제이쿼리는 수많은 제이쿼리 플러그인과 함께 인기를 얻기 시작해 점차 자바스크립트의 비공식 표준으로 자리 잡기 시작했다. 이와 더불어 인터넷 익스플로러 8 애서 등장한 로컬 스토리지, 2011년 공식적으로 표준으로 등록된 웹소켓, 자바스크립트로 그래픽을 표현할 수 있도록 도와준 캔버스나 백터 그래픽을 표현할 수 있는 SVG, 사용자의 위치를 알 수 있는 지오로케이션등 점차 다양한 기능을 브라우저에서 지원하기 시작했고,

ES5가 처음으로 표준 스펙으로 자리잡았다. 이러한 브라우저와 생태계의 변화에 맞춰 서버에서 생성한 HTML 페이지를 보여주고 간단한 폼 처리 정도만 하던 브라우저 환경은 급변하기 시작했다. 자바스크립트는 적극적으로 DOM을 수정해 사용자에게 다양한 인터랙션을 보여주었고, Ajax를 활용해 서버뿐만 아니라 클라이언트에서도 서버와 통신해서 데이터를 불러오기 시작했다. 이에 따라 자바스크립트 코드가 점차 복잡해지기 시작했다.

이러한 필요성 때문에 등장한 것이 구글에서 만든 Angler와 coffeeScript와 Underscore.js의 제작자 제레미 아쉬케나스가 선보인 Backbone이였다. 두 프레임워크는 비슷한 시기인 2010년 10월 20일과 2010년 10월 13일 각각 릴리스됐다. 각각 MVVM 과 MVC패턴을 기반으로 나날이 복잡해지는 자바스크립트 코드를 체계화하고자 노력했다.

그럼 이때 당시 페이스북은 어떤 상황이었는지 살펴보자, 이 당시 페이스북은 전 세계적으로 약 7억 명 정도의 사용자가 이용하는, 전 세계적인 인기를 구가하는 소셜 네트워크 서비스로 자리 잡았다. 전례 없이 많은 사용자가 이용하는 서비스이니만큼 성능이 그 무엇보다 중요했다. 페이스북은 이를 위해 최대한 서버에서 렌더링하는 기술을 사용했고, 자바스크립트 번들의 크기를 줄이는 데 오랜 기간 심혈을 기울였다. 자바스크립트 코드의 크기가 늘어날수록 이를 다운로드 하고, 파싱하고, 실행해야 하는 브라우저의 부담이 커지는 것이 당연했기 때문이다. 따라서 자바스크립트는 반드시 필요한 곳에서만 제한적으로 사용하고자 노력했다. 그런 노력에도 불구하고 자바스크립트 코드는 커질 수밖에 없고, 서버 렌더링이 처리할 수 있는 규모에는 한계가 있을 수밖에 없었다.

페이스북에게 있어 웹의 중요성을 더욱 부각시킨 사건이 있었으니 바로 스파르탄 프로젝트다. 스파르탄 프로젝트는 이 당시 애플의 강력한 앱 규제에 반발해 만들어진 프로젝트로, 페이스북 ios 앱 대신 애플의 사파리(webkit)에서 작동할 수 있는 페이스북을 만들기 위해 추진됐다. 이를 통해 앱스토어에 등록할 필요가 없으며, 결국에는 애플의 앱스토어 규제에서 벗어날 수 있게 되는 것이다. 또한 이 무렵 등장한 HTML5는 표준만 잘 지킨다면 PC나 모바일 환경에 상관없이 모두 동일한 서비스를 제공할 수 있는 가능성을 제시했다. 그래서 페이스북 팀은 HTML5 기반으로 페이스북을 완전히 재작성하는 스파르탄 프로젝트를 시작하게 된다.

그러나 앞으로 모든 애플리케이션을 HTML5로ㄹㅇ 만들어 하이브리드 앱으로 페이스북을 만들겠다는 스파르탄 프로젝트는 성공하지 못했다. 이후 18개월동안 IOS용 페이스북 앱을 네이티브로 다시 개발하고, 뒤이어 안드로이드 네이티브 페이스북 앱도 출시하면서, 마크 주커버그는 공식적으로 스파르탄 프로젝트가 실패했음을 알렸다.

### BoltJS의 등장과 한계

페이스북은 바닐라JS, jQuery, Angular와 Backbone.js로는 사용자에게 만족스러운 경험을 안겨주기 어렵다고 판단했디. 그래서 BoltJs라고하는 새로운 프레임워크를 만들어 페이스북을 다시만들었다.

createClass로 내부에 객체를 선언해서 컴포넌트를 만드는 방식은 이후에 리액트 초기 버전인 React.createClass가 이어받게 된다.

그러나 이 BoltJS의 소스코드가 실제 프로덕션 서비스에서 사용되는 일은 없었다. 잠깐 깃허브를 통해 공개 됐지만 제대로 된 이유를 알려주지 않은 채 동연 소스코드가 삭제됐다. 아마도 내부에서 아직 공개하기엔 무리가 있는 코드로 판단했던 것으로 보인다. 많은 개발자들이 BoltJS로 페이스북을 클론하려고 시도했지만 프로젝트 아키텍처는 점점 복잡해지기 시작했으며 점차 변화를 가져가기 어려웠다고 밝혔다. 그 후 BoltJS 개선을 위해 내놓은 아이디어 중 하나가 바로 Functional Bold.즉 Fbolt였다. 이당시 제안됐던 아이디어 중 하나는 애플리케이션에서 API의 변화에 따라 무언가 변경되면 단순히 UI를 초기화하고 새로 렌더링 하자는 것이였는데, 이 당시 이러한 접근법은 프론트엔드 개발자 사이에서 매우 파격적인 접근법이었다.

이 당시 개부분 프레임워크는 양방향 바인딩 구조를 채택해 모델과 뷰가 밀접한 관계를 맺고 서로를 변경할 수 있는 구조였다. 이러한 구조는 코드를 작성하는 것은 간단하지만 변경된 DOM을 추적하는 것이 어렵고, 왜 이렇게 변경됐는지 역시 추적하기 어려워 수많은 버그가 발생하던 지점이기도 했다.

그런데 이러한 방법 대신 모델이 뷰를 변경하는 단방향 방식으로, 모델의 데이터가 변경되어 뷰가 변경되어야 하면 이전 DOM을 버리고 개롭게 렌더링하는 방식을 제안했다. 하지만 DOM의 변경을 최소한으로 하는것이 성능을 위한 최선의 방법으로 여겨졌던 시기라 이러한 방식이 성능을 보장할 수 있을지 의구심을 품는 개발자들이 많았다.

그럼에도 한편으로는 유용한 방식이기도 했다. 페이스북 프론트엔드 개발자들이 느끼는 가장 큰 어려움은 DOM을 업데이트하는 것이었다. 좋아요 버튼의 클릭 이벤트 리스너를 등록하고 이를 제거하고 다시 찾고, 다시 또 속성을 변경하는 작업은 매우 복잡했고 버그의 주요 원인이었으며 개발자들도 원인 파악이 힘들었다. 이러한 상황에서 성능은 둘째 치고 그냥 다시 새롭게 렌더링해 버리는 것은 어찌 보면 좋은 생각이 될 수도 있었고 데모로 구현한 리액트는 많은 사람들에게 영감을 주었고, 성능 또한 크게 나쁘지 않다는 것을 확인받을 수 있었다. 그렇게 리엑트 프로젝트가 시작됐다.

### 페이스북 팀의 대안으로 떠로른 리액트

리액트의 첫 번째 프로젝트는 게시물 하단에 있는 댓글, 공유 버튼이 있는 화면인 UFI(Universal Feedback Interface)를 구현하는 것이었다.

간단해 보이는 화면을 구현하는건 그당시 굉장히 복잡한 일어었다. 좋아요를 누르거나 댓글을 다는 행위는 모두 즉각적으로 이루어지길 바랬고, 이는 거의 채팅과 같은 반응 속도로 이뤄져야 했다. 이 UFI는 모든 포스트에 존재했고 많아질수록 버그가 발생할 여지가 컸다. 이를 해결하기 위해 JSX 구문과 Flux패턴에 대한 아이디어가 등장했다.

그 후 페이스북은 인스타그램을 인수했다. 인스타그램은 그 당시 IOS와 안드로이드 버전밖에 없었지만, 페이스북의 웹 기반 개발의 기조에 맞춰, 인스타그램을 웹으로 만드는 작업에 착수했다. 그때 선택한것은 리액트였다.

처음부터 리액트로 만들어진 인스타그램, 그리고 기존 페이스북의 거대한 PHP애플리케이션 중 일부를 리액트로 조금씩 대체하기 시작하면서, 페이스북 개발자들은 리액트에 대한 자신감을 조금씩 얻기 시작했다. 이와 동시에 리액트를 오픈소스로 공개하고자 하는 노력도 함께 이루어지고 있었다. 그리고 이러한 리액트를 공개할 무대로 JSConf US를 선택했고, 여기서 리액트와 함께 embedded XML인 JSX도 함께 공개했다.

### 리액트에 대한 회의적인 의견과 비판

JSConf US 2013에서 공개된 리액트에 대한 반응은 그다지 좋지 못했다. 좋지 못한 것을 넘어서 대부분이 싫어했다.그당시 컴공에서 말하는 관심사 분리의 원칙을 지키기 위한 기초적인 사실로 받아들였기 때문에 JS와 HTML이 함께 존재하는 JSX 는 말도 안되는 것으로 비쳤다. 사실 리액트의 구조도 관심사 분리의 원칙을 다른다고 볼 수 있다. 당시의 관심사 분리는 HTML, 자바스크립트, CSS가 각기 다른 폴더와 파일로 분리되고, 파일의 역할별로 관심사가 분리되는 것에 초점이 맞춰져 있었다. 하지만 당시 페이스북 팀이 간과하고 있었던 사실 중 하나는, 페이스북 팀과 일반적인 웹 개발자의 관점의 차이다. 페이스북 팀은 앞서 설명한 것처럼 점점 복잡해져가는 웹 어플리케이션을 좀 더 효율적으로 관리하기 위한 새로운 프레임워크에 초점을 맞춰 개발했지만 이러한 사실이 JSConf를 통해 잘 전달되지 않았던 것으로 보인다.

### 드디어 빛을 보는 리액트

그러나 모두가 리액트에 거부감을 느낀 것은 아니었다. 일부는 리액트의 접근 방식에 흥미를 느꼈고 프로덕션 애플리케이션에 리액트를 도입하는 사람들이 생겨났고, 리액트의 개발자가 아닌 외부의 개발자들이 리액트에 새로운 아이디어와 활기를 불어넣기 시작하면서 리액트는 새로운 원동력을 얻기 시작했다.

이 후 리액트는 커뮤니티의 지지를 받으며 점차 성장해 나가기 시작했다. 리액트 커뮤니티는 리액트가 제공하지 못한 것을 채워주기 위해 상태 관리 라이브러리, 라우터 라이브러리, 서버 사이드 렌더링 프레임워크 등이 등장하기 시작하면서 점차 리액트는 프론트엔드 생태계에서 자리잡기 시작했다. 이같은 리액트의 성장을 다른 IT 기업들도 눈여겨보기 시작했고, 점차 리액트를 채택하는 곳이 등장하기 시작했다.

리액트를 앞서 채택한 웹사이트 중 하나는 바로 야후! 메일이다. 최초의 야후메일은 C++와 HTML로 제작됐지만 시간이 지나며 다른 웹사이트처럼 PHP와 JS를 기반으로 하고 있었다. 그러나 기능이 점차 추가되고 요구사항이 복잡해지면서 전통적인 MVC 패턴을 유지해 개발하는 것에 어려움을 느꼈으며 예측 가능한 데이터 흐름, 독립적인 컴포넌트 개발 등을 목표로 리액트와 Flux패턴을 도입했다.

또 하나 리액트를 채택한 유명한 웹사이트는 바로 넷플릭스다. 넷플릭스는 원래 자바를 기반으로 만들어졌지만, 여러 가지 문제점이 있었다. 최초 상호작용에 걸리는 시간이 평균적으로 5초 정도 소요됐고, 웹 사이트 빌드는 20분 가까이 걸리고 있었다. 무엇보다, 기능을 추가하는 데도 매우 오랜 시간이 걸려 개발자들이 어려움을 겪고 있었다. 그후 리엑트를 염두해 두고 리액트와 백복으로 프로토 타입을 만들어보기 시작했다. 그 결과, 리액트가 몇 가지 더 확실한 장점을 가지고 있음을 깨닫게 된다.

- 자바스크립트 코드의 크기가 줄었다, 상태를 관리하기 위한 컨트롤러 대신, 리액트는 단지 상태에 따른 UI를 선언적으로 구현할 수 있었으므로 코드를 좀 더 간결하게 작성할 수 있었다. 이러한 복잡성을 줄인 것만으로도 전체 코드의 크기를 확연하게 줄일 수 있었고, 그 결과 최초 상호작용에 걸리는 시간이 5chdptj 1.5초로 감소했다.
- HTML,JS만 알면 손쉽게 리액트 코드를 작성할 수 있었다.
- 과거에 비해 빌드 시간이 훨씬 빨랐다.

전세계에서 두 번째로 큰 IT회사인 넷플릭스가 리액트 생태계에 뛰어들자 반신반의하던 프론트엔드 커뮤니티도 환호하기 시작했다. 이와 비슷한 시기에 열린 React.js Conf도 순식간에 매진되면서 성황리에 치러졌다.

### 리액트의 현재와 미래

2013년 5월에 최초 공개된 리액트의 버전은 0.3.0이고 현재 2024년 기준 최신 버전은 18버전이다 한가지 재밌는 사실은 0.14.7 이후로 바로 버전이 15로 넘어갔다는 것이다. 유의적 버전을 지키고자 노력하고 있기 때문에 크게 걱정하지 않아도 될 것으로 보인다.

앞서 언급한 것처럼 리액트는 현재 가장 인기있는 프레임워크로 자리 잡았다. 웹개발을 위한 프레임워크를 지향하지 않으므로 리액트와 함께 사용할 수 있는 다양한 라이브러리가 있다.

react라는 이름이나 태그를 가지고 있는 npm 패키지 또한 현재 23만여 개에 달한다.

국내 IT 업계도 리액트가 프론트엔드의 대세인 것으로 보이며, 리액트를 주력으로 사용하고 있고 slash라는 라이브러리에서 일부 리액트향 라이브러리도 제공하고 있다. 카카오도 마찬가지로 리액트를 사용하고 있으며, 네이버도 조직별로 차이가 있겠지만 최근 네이버 PC 메인과 지도 메인을 리액트로 바꾼 것으로 보아 내부적으로 리액트를 주력으로 사용하고 있는 것으로 보인다.

과거 리액트는 클라이언트에 초점을 맟추고 있었고, 앞으로도 브라우저와 클라이언트에서의 작동을 개선할 예정이라고 밝혔다. 그러나 리액트 팀은 클라이언트에서는 할 수 없는 서버에서의 작업, 그리고 서버 환경이 가지고 있는 가능성에 무게를 두고 앞으로도 서버에서 작동할 수 있는 다양한 기능이나 유스케이스를 추가할 것으로 보인다. 따라서 앞으로도 리액트를 계속해서 공부할 것이라면 프론트엔드 개발자들도 Node.js 같은 서버 환경을 공부하는 것이 기본 소양으로 자리 잡게 될 것이다.
