## 1.5. 이벤트 루프와 비동기 통신의 이해

자바스크립트는 싱글 스레드에서 작동된다. 즉, 기본적으로 자바스크립트는 한 번에 하나의 작업만 동기 방식으로만 처리할 수 있다. 동기(synchronous)에 대해 간단하게 설명하자면 직렬 방식으로 작업을 처리하는 것을 의미하며, 이 요청이 시작된 이후에는 무조건 응답을 받은 이후에야 비로서 다른 작업을 처리할 수 있다. 그 동안 모든 작업은 대기한다. 이러한 방식은 개발자에게 매우 직관적으로 다가오지만 한 번에 다양한 많은 작업을 처리할 수 없다. 반대의 의미인 비동기(asynchronous)란 직렬 방식이 아니라 병렬 방식으로 작업을 처리하는 것을 의미한다. 요청을 시작한 후 이 응답이 오건 말건 상관없이 다음 작업이 이루어지며, 따라서 여러 작업이 실행될 수 있다.

### 1.5.1. 싱글 스레드 자바스크립트

자바스크립트는 싱글 스레드 언어라는 말을 많이 들어봤을 것이다. 과거에는 프로그램을 실행하는 단위가 오직 프로세스 뿐이었다. 프로세스란 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위를 의미한다. 즉 하나의 프로그램 실행은 하나의 프로세스를 가지고 그 프로세스 내부에서 모든 작업이 처리되는 것을 의미했다. 그러나 소트웨어가 점차 복잡해지면서 하나의 프로그램에서 동시에 여러개의 복잡한 작업을 수행할 필요성이 대두됐다. 하지만 하나의 프로그램에는 하나의 프로세스만이 할당 되므로 이러한 작업을 수행하기 어려웠는데, 그래서 탄생한 더 작은 실행 단위가 바로 스레드다. 하나의 프로세스에서는 여러개의 스레드를 만들 수 있고, 스레드끼리는 메모리를 공유할 수 있어 여러가지 작업을 동시에 수행할 수 있다. 그래서 프로세스 내부에서 여러개의 스레드를 활용하면서 동시 다발적인 작업을 처리할 수 있게 된 것이다.

자바스크립트는 왜 싱글 스레드로 설계됐을까? 먼저 멀티 스레드는 앞서 언급한 여러가지 이점이 있지만 내부적으로 처리가 복잡하다는 단점이 있다. 동시에 여러 작업을 수행하다 보면 같은 자원에 대해 여러 번 수정하는 등 동시성 문제가 발생할 수 있어 이에 대한 처리가 필요하다. 또한 각각 격리돼 있는 프로세스와는 다르게 하나의 스레드가 문제가 생기면 같은 자원을 공유하는 다른 스레드에도 동시성 문제가 일어날 수 있다.

이러한 특징을 토대로 과거 자바스크립트의 역할을 다시금 상기해볼 필요가 있다. 최초의 자바스크립트는 브라우저에서 HTML을 그리는 데 한정적인 도움을 주는 보조적인 역할로 만들어졌었다.

자바스크립트는 1995년경 첫 선을 보였다. 그리고 그 당시에는 아직 멀티 스레드에 대한 개념이 대중화되던 시기가 아니였다. 그리고 1995년 에는 넷스케이프 개발자 브렌던 아이크가 브라우저에서 아주 간단한 스크립트를 지원할 목적으로 LiveScript(자바스크립트의 전신)을 만들었던 것이 자바스크립트의 시작이다. 최초의 자바스크립트는 이름에서 유추할 수 있는 것처럼 다른 여러 가지 언어를 참고해 단 10일 만에 첫 버전이 완성됐다 설꼐가 빨리 되고 다른 언어를 참고하던 것을 차치하고서라도 최초의 자바스크립트는 단순히 버튼위에 이미지를 띄우거나 간단한 경고창을 띄우거나 폼을 처리하는 등 아주 기초적인 수준에서만 제한적으로 사용됐다. 즉, 설계 당시에는 약 30년 뒤 현재처럼 자바스크립트로 웹페이지에서 벌어지는 온갖 다양한 일을 처리해야할것이라고 생각을 못했을 것이다.

다시 싱글 스레드 자바스크립트로 돌아와서 자바스크립트가 싱글 스레드라는 것은 무엇을 의미할까? 자바스크립트 코드의 실행이 하나의 스레드에서 순차적으로 이루어진다는 것을 의미한다. 하나의 스레드에서 순차적으로 이루어진다는 것은 코드를 한줄한줄 실행한다는 것을 의미하며 궁극적으로 하나의 작업이 끝나기 전까지는 뒤이은 작업이 실행되지 않는다는 것을 의미한다. C언어나 다른 메이저 프로그래밍 언어에서는 스레드에서 실행중인 함수를 시스템이 임의로 멈추고 다른 스레드의 코드를 먼저 실행할 수 있지만 자바스크립트에는 그런 기능이 존재하지 않는다. webWorker를 활용하면 동시에 여러 작업을 처리할 수 있지만 이 기능은 최근에 나온 것으로 논외로 한다.

자바스크립트에서 하나의 코드가 실행하는 데 오래걸리면 뒤이은 코드가 실행되지 않는다는 것을 알고있을것이다. 이러한 자바스크립트의 특징을 run to completion이라고 한다. 이러한 특징은 자바스크립트 개발자에게 동시성을 고민할 필요가 없다는 아주 큰 장점이 되지만, 반대로 때에 따라서 웹페이지에서는 단점이 될 수 있다. 하나의 작업이 끝나기 전까지 다른 작업이 실행되지 않으므로 어떠한 작업이 오래 걸린다면 사용자에게 마치 웹페이지가 멈춘 것 같은 느낌을 줄 수 있다. 결론적으로 run-to-completion 즉 자바스크립트의 모든 코드는 동기식으로 한번에 하나씩 순차적으로 처리된다.

그렇다면 비동기는 무엇일까? 자바스크립트에서 비동기 함수를 선언할 때 쓰는 async는 영어로 asynchronous 즉 동시에 일어나지 않는 것을 의미한다. 동기식과 다르게 요청한 즉시 결과가 주어지지 않을 수도 있고 따라서 응답이 언제 올지도 알 수 없다. 그러나 동기식과 다르게 여러 작업을 동시에 수행할 수 있다는 장점이 있앋.

```jsx
console.log(1);

setTimeout(() => {
  console.log(2);
}, 0);

setTimeout(() => {
  console.log(3);
}, 100);

console.log(4);

// 1 4 2 3 순서로 출력
```

동기식으로 작동하는 자바스크립트에서 어떻게 이런 비동기 코드를 처리할 수 있는 것일까? 이러한 사실을 이해하려면 이벤트 루프라는 개념을 이해해야 한다.

### 1.5.2. 이벤트 루프란?

먼저 지금부터 설명하는 내용은 자바스크립트 런타임 중에서 가장 유명한 V8을 기준으로 작성됐다. 다른 자바스크립트 런타임에서는 작동에 약간의 차이가 있을 수 있다.

먼저 이벤트루프는 ECMASript, 즉 자바스크립트 표준에 나와있는 내용은 아니다. 즉이벤트루프란 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치라 볼 수 있다. V8, Spider Monkey같은 현대의 자바스크립트 런타임 엔진에는 자바스크립트 코드를 효과적으로 실행하기 위한 여러 가지 장치들이 마련돼 있다.

**호출 스택과 이벤트 루프**

호출 스택은 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택이다.

```jsx
function bar() {
  console.log("bar");
}

function bas() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  bar();
  baz();
}

foo();
```

이 코드는 foo를 호출하고, 내부에서 bar,baz를 순차적으로 호출하는 구조로 돼있다. 이 코드들은 대략 다음과 같은 순서로 호출 스택에 쌓이고 비워지게 된다.

1. foo()가 호출 스택에 먼저 들어간다.
2. foo() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
3. 2의 실행이 완료된 이후에 다음 코드로 넘어간다. 아직 foo()는 존재
4. bar가 호출스택에 들어간다.
5. bar 내부에 console.log가 존재하므로 호출 스택에 들어간다.
6. 5의 실행이 완료된 이후에 다음 코드로 넘어간다.
7. 더이상 bar에 남은 것이 없으므로 호출 스택에서 제거된다.
8. baz가 호출 스택에 들어간다.
9. baz내부의 console.log가 존재하므로 호출 스택에 들어간다.
10. 9의 실행이 완료된 이후에 다음 코드로 넘어간다.
11. 더이상 baz에 남는 것이 없으므로 호출 스택에서 제거된다.
12. 더이상 foo에 남는 것이 없으므로 호출 스택에서 제거된다.
13. 이제 호출 스택이 완전히 비워졌다.

이 호출 스택이 비어 있는지 여부를 확인하는 것이 바로 이벤트 루프다. 이벤트 루프는 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택내부에 수행해야 할 작업이 있는지 확인하고, 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다. 한 가지 알아둘 점은 코드를 실행하는 것 과 호출 스택이 비어 있는지 확인하는 것 모두가 단일 스레드에서 일어난다는 점이다.

```jsx
function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

function foo() {
  console.log("foo");
  setTimeout(bar(), 0);
  baz();
}

foo();

// foo baz bar 순서로 출력
```

1. foo가 호출스택에 먼저 들어간다.
2. foo 내부에 console.log 가 존재하므로 호출 스택에 들어간다.
3. 2의 실행이 완료된 이후에 다음 코드로 넘어간다.
4. setTimeout이 호출 스택에 들어간다.
5. 4번에 대해 타이머 이벤트가 실행되며 태스크 큐로 들어가고 그대신 바로 스택에서 제거된다.
6. baz 가 호출 스택에 들어간다.
7. baz내부에 console.log가 존재하므로 호출 스택에 들어간다.
8. 7의 실행이 완료된 이후에 다음 코드로 넘어간다.
9. baz는 호출 스택에서 제거된다.
10. foo는 호출 스택에서 제거된다. 그리고 호출 스택이 완전히 비워졌다.
11. 이벤트 루프가 호출 스택이 비워져 있다는 것을 확인하고, 태스크 큐를 확인해 bar를 호출스택에 보낸다.
12. bar의 console.log를 호출스택에 들어간다.
13. 12번의 실행이 끝나고 다음 코드로 넘어간다.
14. 더 이상 bar에 남은 것이 없으므로 호출 스택에서 제거된다.

위 코드를 보면, setTimeout이 정확하게 0초뒤에 실행된다는 것을 보장하지 못한다는 것을 이해하게 될 것이다.

여기서 부터 태스크 큐라는 새로운 개념이 등장한다. 태스크 큐란 실행해야 할 태스크의 집합을 의미한다. 이벤트 루프는 이러한 태스크 큐를 한 개 이상 가지고 있다. 그리고 이름과는 다르게 태스크 큐는 자료 구조의 큐가 아니고 set 형태를 띠고 있다. 그 이유는 선택된 큐 중에서 실행 가능한 가장오래된 태스크를 가져와야 하기 때문이다. 자료구조인 큐는 무조건 앞에 있는 것을 FIFO형식으로 꺼내와야 하지만 태스크 큐는 그렇지 않다. 태스크큐에서 의미하는 실행해야 할 태스크 라는 것은 비동기 함수의 콜백함수나 이벤트 핸들러 등을 의미한다.

그렇다면 마지막으로궁금해지는 것은 저 비동기 함수는 누가 수행하느냐다. n초 뒤에 setTimeout을 요청하는 작업은 누가 처리할까? fetch를 기반으로 실행되는 네트워크 요청은 누가 보내고 응답을 받을 것인가? 이러한 작업들은 모두 자바스크립트 코드가 동기식으로 실행되는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행된다. 이 별도의 스레드에서 태스크 큐에 작업을 할당해 처리하는 것은 브라우저나 Node의 역할이다. 즉 자바스크립트 코드 실행은 싱글 스레드에서 이루어지지만 이러한 외부 web api등은 모두 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어가는 것이다. 이벤트 루프는 호출 스택이 비고, 콜백이 실행가는한 때고 오면 이것을 꺼내서 수행하는 역할을 하는 것이다. 만약 이러한 작업 들도 모두 자바스크립트 코드가 실행되는 메인 스레드에서만 이루어진다면 절대로 비동기 작업을 수행할 수 없을 것이다.

### 1.5.3. 태스크 큐와 마이크로 태스트 큐

태스크 큐와 다르게, 마이크로 태스트 큐라는 것도 있다. 이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있는데, 기존의 태스크 큐와는 다른 태스크를 처리한다. 여기에 들어가는 마이크로 태스크에는 대표적으로 Primise가 있다. 이 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다. 즉 setTimeout과 setInterval은 Promise보다 늦게 실행된다. 명세에 따르면, 마이크로 태스크 큐가 실행 될때 까지는 기존 태스크 큐의 실행은 뒤로 미뤄진다.

```jsx
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

function baz() {
  console.log("baz");
}

setTimeout(foo, 0);

Promise.resolve().then(bar).then(baz);
```

예제 코드를 실행하면 bar,baz,foo 순으로 실행된다. 확실히 Promise가 우선권이 있음을 알 수 있다.

각 태스크에 들어가는 대표적인 작업은 다음과 같다.

태스크 큐: setTimeout, setInterval, setImmediate

마이크로 태스크 큐: process, nextTick, Promises, queueMicroTask, MutationObserver

그런다면 렌더링은 언제 실행될까? 태스크 큐를 실행하기에 앞서 먼저 마이크로 태스크 큐를 실행하고, 이 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어난다. 각 마이크로 태스크 큐 작업이 끝날 때마다 한번씩렌더링할 기회를 얻게 된다.

```jsx
<html>
  <body>
    <ul>
      <li>동기 코드: <button id="sync">0</button></li>
      <li>태스크: <button id="macrotask" 0></button></li>
      <li>마이크로 태스크: <button id="microtask">0</button></li>
      <button id="macro_micro">모두 동시 실행</button>
    </ul>

    <script>
      const button = document.querySelector("run");
      const syncButton = document.getElementById("sync");
      const macroTask = document.getElementById("macrotask");
      const microTask = document.getElementById("microtask");

      const macro_micro = document.getElementById("macro_micro");
      sync.this.addEventListener("click", function () {
        for (let i = 0; i < 100000; i++) {
          syncButton.innerText = i;
        }
      });

      macroTask.addEventListener("click", function () {
        for (let i = 0; i < 100000; i++) {
          setTimeout(() => {
            macroTask.innerText = i;
          }, 0);
        }
      });

      microTask.addEventListener("click", function () {
        for (let i = 0; i < 100000; i++) {
          queueMicrotask(() => {
            microTask.innerText = i;
          });
        }
      });

      macro_micro.addEventListener("click", function () {
        for (let i = 0; i < 100000; i++) {
          syncButton.innerText = i;
          setTimeout(() => {
            macroTask.innerText = i;
          }, 0);
          queueMicrotask(() => {
            microTask.innerText = i;
          });
        }
      });
    </script>
  </body>
</html>
```

위 예제 코드의 결과를 정리하면 다음과 같다.

- 동기 코드는 우리가 예상했던 것처럼 해당 연산, 즉 100000까지 숫자가 올라가기 전까지 렌더링이 일어나지 않다가 for문이 끝나야 비로소 렌더링 기회를 얻으며 100000이라는 숫자가 한 번에 나타난다.
- 태스크 큐는 모든 setTimeout 콜백이 큐에 들어가기 전까지 잠깐의 시간을 갖다가 1부터 100000까지 순차적으로 렌더링되는 것을 볼 수 있다.
- 마이크로 태스크큐는 동기 코드와 마찬가지로 렌더링이 전혀 일어나지 않다가 100000까지 다 끝난 이후에 한번에 렌더링이 일어난다.
- 모든 것을 동시에 실행했을 경우 동기 코드와 마이크로 태스크 큐만 한번에 100000까지 올라가고, 태스크 큐만 앞선 예제처럼 순차적으로 렌더링 되는 것을 볼 수 있다.

이러한 작업 순서는 브라우저에 다음 리페인트 전에 콜백함수 호출을 가능하게 하는 requestAnimationFrame으로도 확인할 수 있다.

```jsx
console.log('a')
setTimeout(()=>{
	console.log('b')
}, 0)

Promise.resolve().then(()=>{
	console.log('c')
})

window.requestAnimationFrame(()=>{
	console.log('d')
}
```

위 코드를 실행하면 a,c,d,b, 순서로 출력된다. 즉 브라우저에 렌더링하는 작업은 마이크로 태스크 큐와 태스크 큐 사이에서 일어난다는 것을 알 수 있다.

### 1.5.4. 정리

자바스크립트 코드를 실행하는 것 자체는 싱글 스레드로 이루어져서 비동기를 처리하기 어렵지만, 자바스크립트 코드를 실행하는 것 이외 태스크 큐, 이벤트 루프, 마이크로 태스크 큐, 브라우저/Node.js API 등이 적절한 생태계를 이루고 있기 때문에 싱글 스레드로는 불가능한 비동기 이벤트 처리가 가능해진 것이다.
