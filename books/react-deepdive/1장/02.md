# [스터디] 리액트 딥다이브 -1-2 (함수)

## 1.2. 함수

굳이 자바스크립트에서 함수의 중요성을 언급하지 않아도, 자바스크립트와 리액트에서 반드시 알아야 할 내용이 바로 함수다. 리액트에서 함수 컴포넌트를 작성하다 보면 화살표 함수와 일반 함수를 혼재해서 쓰는 경우가 많은데 정작 두 함수의 차이에 대해서는 정확히 모르는 경우가 많다. 함수의 다양한 형태와 이러한 함수의 차이점이 무엇인지 살펴보자.

### 1.2.1. 함수란 무엇인가?

자바스크립트에서 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것을 의미한다.

```jsx
function sum(a, b) {
  return a + b;
}
```

먼저 function으로 시작해 }로 끝나는 부분까지가 함수를 정의한 부분이다. function 뒤에 오는 것이 함수명, 그리고 함수의 입력값으로 받는 a,b를 각각 매개변수라 하며 return으로 작성된 것이 반환값이다.

리액트에서 컴포넌트를 만드는 함수도 이러한 기초적인 형태를 따르는 것을 알 수 있다.

```jsx
function Component(props) {
  return <div>{props.hello}</div>;
}
```

Component라고 하는 함수를 선언하고 매개 변수로는 일반적으로 props라고 부르는 단일 객체를 받으며 return문으로 jsx를 반환한다.

리액트에서는 함수 컴포넌트는 <Component hello={props.hello}/> 와 같이 JSX문법으로 단일 props별로 받거나, <Component {…props}/> 같은 형태로 모든 props를 전개 연산자로 받는다는 차이가 있다. 그리고 이러한 jsx형태 외에도 일반적인 자바스크립트 분법으로 함수 컴포넌트를 호출하는 것도 가능하다. 이에 대해서는 2.1절에서 다룬다.

### 1.2.2. 함수를 정의하는 4가지 방법

자바스크립트에서 함수를 정의하는 방법을 크게 4가지로 나눌 수 있다. 리액트를 이미 다뤄본 사람이라면 리액트 애플리케이션 내부에서 다양한 방식으로 함수를 정의한다는 것을 알 수 있다. 그리고 이러한 호출 방식에는 조금씩 기술적인 차이가 있다. 여기서는 함수를 선언하는 방법과 각 방법 간에 어떤 차이가 있는지 살펴보자.

함수 선언문

일반적인 사용 방식

```jsx
function add(a, b) {
  return a + b;
}
```

함수 선언문은 표현식이 아닌 일반 문으로 분류된다. 표현식이란 무언가 값을 산출하는 구문을 의미한다. 즉 앞선 함수 선언으로는 어떠한 값도 표현되지 않았으므로 표현식이 아닌 문으로 분류된다.

```jsx
const sum = function sum(a,b){
	reutnr a+b
}
sum(10,24)//34
```

앞서 함수 선언문의 정의에 따르면, 함수 선언문은 말 그대로 선언이고 어떠한 값도 표현하지 않았으므로 표현식과는 다르게 변수에 할당할 수 없는 것이 자연스러워 보인다. 그러나 위 예제는 마치 sum이라는 변수에 함수 sum을 할당하는, 표현식과 같은 작동을 보였다. 따라서 위와 같이 이름을 가진 형태의 함수 리터럴은 코드 문맥에 따라 전자와 같은 선언문으로도, 후자와 같은 표현식으로도 사용될 수 있음을 알고 있어야 한다.

함수 표현식

함수 표현식에 대해 알아보기 전에 일급 객체라는 개념을 알고 있어야 한다. 프로그래밍 세계에서 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다. 자바스크립트에서 함수는 일급 객체다. 함수는 다른 함수의 매개변수가 될 수도 있고, 반환값이 될 수도 있으며, 앞에서 본 것처럼 할당도 가능하므로 일급 객체가 되기 위한 조건을 모두 갖추고 있다.

앞서 함수가 일급 객체라고 했으니, 함수를 변수에 할당하는 것은 당연히 가능하다.

```jsx
const sum = function (a, b) {
  return a + b;
};

sum(10, 20); // 30
```

함수 표현식에서는 할당하려는 함수의 이름을 생략하는 것이 일반적이다. 그 이유는 코드를 봤을 때 혼란을 방지하기 위함이다.

```jsx
const sum = function add(a,b){
	// 함수 몸통에서 현재 실행중인 함수를 참조하는 데 사용할 수 있다.
	// 이는 단순히 코드에 대한 이해를 돕기 위한 예제 코드고
	// 실제 프로덕션 코드에서는 절대로 시용해서는 안된다.
	// https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Function/argments/callee
	console.log(arguments.callee.name
}
sum(10,24) //34
add(10,24) // Uncaught ReferenceError: add is not defined
```

위 함수 표현식 예제를 살펴보면 실제로 함수를 호출하기 위해서 사용된 것은 sum임을 알 수 있다. 그리고 add는 실제 함수 내부에서만 유효한 식별자일 분 함수 외부에서 호출하는 데에는 사용할 수 없는 식별자다. 따라서 함수 표현식에서 함수의 이름을 주는 것은 함수 호출에 도움이 전혀 안 되는, 코드를 읽는 데 방해가 될 수 있은 요소임을 알 수 있다.

### 함수 표현식과 선언 식의 차이

위의 두가지 방식의 차이점을 살펴보자. 이 두 가지 방식의 가장 큰 차이는 호이스팅 여부이다. 먼저 호이스팅에 대해 알아보자. 함수의 호이스팅이라함은, 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징을 의미한다.

```jsx
hello(); // hello

function hello() {
  console.log("hello");
}

hello();
```

함수를 선언한 hello는 코드 중간에 있음에도 불구하고, 맨 앞에서 호출한 hello()는 어떤 에러도 없이, 그리고 마치 함수가 미리 만들어지기라도 한 것처럼 정상적인 hello 함수의 작동을 수행하는 것을 알 수 있다. 함수의 호이스팅은 함수에 대해 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미한다. 이러한 함수의 호이스팅이라는 특징 덕분에 함수 선언문이 미리 메머리에 등록 됐고, 코드의 순서에 상관없이 정상적으로 함수를 호출할 수 있게 된 것이다. 반면 함수 표현식은 함수를 변수에 할당했다. 변수도 마찬가지로 호이스팅이 발생한다. 그러나 함수의 호이스팅과는 다르게, 호이스팅되는 시점에서 var의 경우에는 undefined로 초기화 한다는 차이가 있다.

```jsx
console.log(typeof hello === "undefined"); // true

hello(); // uncaught TypeError: hello is not a function

var hello = function () {
  console.log("hello");
};

hello();
```

위 예제 코드는 앞선 함수 선언문과 다르게 정상적으로 호출되지 않고, undefined로 남아있는 것을 알 수 있다. 함수와 다르게 변수는 런타임 이전에 undefined로 초기화 되고, 할당문이 실행되는 시점, 즉 런타임 시점에 함수가 할당되어 작동한다는 것을 알 수 있다.

그렇다면 둘 중 어떤 것이 좋을까? 함수를 자유롭게 선언하고 어디서든 자유롭게 호출하고 싶거나, 변수 선언과 다르게 명시적으로 함수를 구별하고 싶을 때는 함수 선언문이 더 좋을 수 있다. 함수 선언문은 함수가 선언된 위치에 상관없이 함수 호이스팅의 특징을 살리면 어디서든 호출할 수 있고, 또 변수 선언과 뚜렷하게 구별되는 차이점이 있다. 그러나 함수가 선언되기 전에 함수가 호출되는 것이 이상하게 느껴지는 사람도 있을 것이다. 함수 호출을 제일 먼저 보이고, 그다음에 실제 함수를 어디서 선언했는지는 해당 스코프를 끝까지 확인하지 않으면 개발자가 찾기 어렵다. 이는 관리해야 하는 스코프가 길어질 경우 특히 더 나쁘게 작용할 수 있다. 그리고 다른 언어를 주로 사용하던 개발자라면 이러한 모습이 어색하게 보일 수 있다.

둘 중에 어떠한 것이 더 낫다거나 기능적으로 우위에 있다고 구별지을 만한 점은 없다. 현재 자바스크립트 코드를 작성하는 환경을 살펴보고, 본인이나 프로젝트의 상황에 맞는 작성법을 일관되게 사용하면 충분하다.

Function 생성자

이 방법은 자바스크립트를 오래 사용했다 하더라도 거의 사용해 본 적이 없을 만한 함수 선언 방식이다. 바로 Function 생성자를 활용하는 방법이다. 앞서 만든 add함수를 생성자 함수로 만들면 다음과 같다.

```jsx
const add = new Function('a','b',return a+b)

add(10,24) // 34
```

Function 생성자 함수를 사용해서 만든 모습은 썩 좋아보이지 않는다. 코드 작성 관점에서 매개변수, 그리고 함수의 몸통을 모두 문자열로 작성해야 한다. 이는 메모정에 코드를 작성하는 것 만큼이나 어려운 방법이며, 코드의 양이 길어진다면 더욱 혼란스러워질 것이다. 도한 이러한 식으로 작성하면 클로저 또한 생성되지 않는다.

화살표 함수

ES6에서 새롭게 추가된 함수 생성 방식으로, 최근 자바스크립트 개발자들 사이에엇 각광받는 함수 정의 방식이다. function이라는 키워드 대신 ⇒ 라는 화살표를 활용해서 함수를 만드는데, 아무래도 타이핑할 글자수가 줄어든다는 측면에서 많이 사용되는 것이 아닌가 싶다.

```jsx
const add = (a, b) => {
  return a + b;
};

const add = (a, b) => a + b;
```

그러나 화살표 함수는 겉보기와 다르게 앞서 언급한 함수 생성 방식과 몇가지 큰 차이점이 있다. 이에 대해 하나씩 살펴보자.

먼저 화살표 함수에서는 constructor를 사용할 수 없다. 즉 , 생성자 함수로 화살표 함수를 사용하는 것은 불가능하다.

```jsx
const Car = (name) => {
  this.name = name;
};

const myCar = new Car("하이");
```

그리고 화살표 함수에서는 arguments가 존재하지 않는다.

```jsx
function hello() {
  console.log(argments);
}

hello(1, 2, 3); // Argument(3) [1,2,3, ...

const hi = () => {
  console.log(argments);
};

hi(1, 2, 3); // Uncaught ReferenceError: arguments is not defined
```

그리고 화살표 함수와 일반 함수의 가장 큰 차이점은 바로 this 바인딩이다. 이 차이로 인해 뒤에 설명할 클래서 컴포넌트에서 이벤트에 바인딩할 메서드 선언 시 화살표 함수로 했을 때와 일반 함수로 했을 때 서로 다르게 동작한다.

this란 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 것이다. 이 this는 화살표 함수 이전까지는 함수를 정의할 때 결졍되는 것이 아니라. 함수가 어떻게 호출되느냐에 따라 동적으로 결정된다. 만약 함수가 일반 함수로서 호출된다면, 그 내부의 this는 전역 객체를 가리키게 된다.

그러나 이와달리 화살표 함수는 함수 자체의 바인딩을 갖지 않는다. 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다.

```jsx
class Component extends React.Coponent {
	constructor(props) {
		super(props)
		this.state = {
			counter: 1,
		}
	}
}

functionCountUp() {
	console.log(this)
	this.setState((prev)=>({ counter: prev.counter + 1 }))
}

ArrowFunctionCountUp = () => {
	console.log(this) // class component
	this.setState((prev)=>({ counter: prew.counter + 1}))
}

render () {
	return {
		<div>
			<button onClick={functioncountUp}>일반 함수</button>

			<button onClick={ArrowFunctionCountUp}>화살표 함수</button>
		</div>
	}
}
```

위 두 메서드는 모두 state를 하나씩 올리는 작업을 동일하게 하고 있다. 그러나 일반 함수에서의 this는 undefined를 화살표 함수에서의 this는 우리가 원하는 대로 클래스의 인스턴스인 this를 가리키는 것을 볼 수 있다. 즉 별도의 작업을 추가로 하지 않고 this에 접글할 수 있는 방법이 바로 화살표 함수인 것이다.

이러한 차이점은 바벨에서도 확인할 수 있다.

```jsx
const hello = () => {
  console.log(this);
};

function hi() {
  console.log(this);
}

// 트랜스 파일된 결과: 바벨에서는 이렇게 변환한다.
var _this = void 0;

var hello = function hello() {
  // 바벨에서 화살표 함수 내부의 _this 자체를 undefined로 바꿔버린다.
  console.log(_this);
};

function hi() {
  console.log(this);
}
```

화살표 함수는 this가 선언되는 시점에 이미 상위 스코프로 결정돼 있어 미리 \_this를 받아서 사용하는 모습과 다르게, 일반 함수는 호출하는 런타임 시점에 결정되는 this를 그대로 따르는 모습이다.

이처럼 화살표 함수의 this는 선언 시점에 결정된다는 일반 함수와 대비되는 큰 차이점이 있기 때문에 단순히 일반 함수의 축약형이라고 보기엔 무리가 있다. 따라서 화살표 함수와 일반 함수를 사용할 때, 특히 this를 사용할 수밖에 없는 클래스 컴포넌트 내부에서 각별한 주의가 필요하다.

### 1.2.3. 다양한 함수 살펴보기

함수를 선언하는 방식이 다양한 것처럼 함수를 사용하는 방식에도 여러가지가 있다. 그중에서도 리액트에서 자주 쓰이는 형태에 대해서만 알아본다.

즉시 실행 함수

즉시 실행 함수(Immediately Invoked Function expression)는 말 그대로 함수를 정의하고 그 순간 즉시 실행되는 함수를 의미한다. 단 한 번만 호출되고, 다시금 호출할 수 없는 함수다.

```jsx
(function(){
	return a + b
})(10,24) // 34
((a,b)=>{
		reutrn a+b
	}
)(10,24)// 34
```

즉시 실행 함수는 한 번 선언하고 호출된 이후부터는 더이상 재호출이 불가능하다. 그래서 일반적으로는 즉시 실행함수에 이름을 붙이지 않는다. 이러한 즉시실행ㅎ 삼수의 특성을 활용하면 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다는 장점을 얻을 수 있다. 함수의 선언과 실행이 바로 그 자리에서 끝나기 때문에 즉시 실행 함수 내부에 있는 값을 그 함수 내부가 아니고서는 접근이 불가능 하기 때문이다.

또한 코드를 읽는 이로 하여금 이 함수는 어디서든 다시금 호출되지 않는다는 점을 각인시킬 수 있어 리팩터링에도 매우 도움이 된다.

고차함수

함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있다. 이런 역할을 하는 함수를 고차 함수라고 한다.

```jsx
// 함수를 매개변수로 받는 대표적인 고차 함수
const doubleArray = [1, 2, 3].map((item) => item * 2);

doubleArray; // [2,4,6]

const add = function (a) {
  return function (b) {
    return a + b;
  };
};

add(1)(3); // 4
```

이러한 특징을 활용해 추후에 다룰 함수 컴포넌트를 인수로 받아 새로운 함수 컴포넌트를 반환하는 고차 함수를 만들 수도 있다. 이런 컴포넌트를 고차 함수와 유사하게 고차 컴포넌트라고 부르는데, 고차 함수 컴포넌트를 만들면 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있어 효울적으로 리펙터링할 수 있다.

### 1.2.4. 함수를 만들 때 주의해야 할 사항

자바스크립트로 코드를 작성하다 보면 변수를 선언하는 것 만큼이나 자주 함수를 만든다. 만들다 보면 함수 생성과 사용에 있어 중요한 부분을 놓칠 수 있다. 함수를 만들기 전에 좋은 함수는 무엇이고 무엇을 조심해야 하는지 알아보자.

함수의 부수 효과를 최대한 억제하라

함수의 부수 효과 란 함수 내의 작동을 ㅗ인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미한다. 이러한 부수 효과가 없는 함수를 순수 함수라 하고, 부수 효과가 존재하는 함수를 비순수 함수라고 한다.

```jsx
function Purecomponent(props) {
  const { a, b } = props;
  return <div>{a + b}</div>;
}
```

이 컴포넌트는 앞선 기준에 따라 순수한 함수 컴포넌트로 분류할 수 있다.

props의 값을 기준으로 a,b 를 더 하고, 그 결과를 HTMLDivElement로 렌더링하고 있다. 외부에 어떤 영향을 미치지도 않았고,언제 어디서든 동일한 인수를 받아서 동일한 결과를 반환하기 때문에 순수한 함수 컴포넌트라 볼 수있다. 순수한 함수는 언제 실행되든 항상 결과가 동일하기 때문에 예측 가능하며 안정적이라는 장점이 있다.

그렇다면 어떻게서든 항상 수수함수로만 작성해야 할까? 그렇지 않다.

웹 애플리케이션을 만드는 과정에서 부수 효과는 어떻게보면 피할 . 수없는 요소다. 컴포넌트 내부에서 API를 호출한다면 어떨까? 외부에 어떠한 영향을 끼쳤으므로 부수 효과다. 피할수 없기 때문에 부수 효과를 최대한 억제할 수 있는 방향으로 함수를 설게해야 한다. 리액트의 관점에서 본다면 부수 효과를 처리하는 훅인 useEffect의 작동을 최소화 하는 것이 그일환이라 할 수있다.

useEffect의 사용은 피할 피할 수 없지만 최소한으로 줄임으로써함수의 역할을 좁히고, 버그를 줄이며, 컴포넌트의 안정성을 높일 수 있다.

가능한 함수를 작게 만들어라

ESLint에는 max-lines-per-function이라는 규칙이 있다. 뜻은 함수당 코드의 길이가 길어질 수록 코드 가 문제를 일으킬 여지가 있고 내부에서 무슨 일이 일어나는지 추적하기 어려워진다. 이 규칙에서는 기본값으로 50줄 이상 넘어가면 과도하게 커진 함수로 분류하고 경고 메시지를 출력한다. 즉 하나의 함수에서 너무나 많은 일을 하지 않게 하는 것이다. 유닉스의 선구자인 더글러스 매킬로이가 말한 것처럼 함수는 하나의 일을, 그 하나만 잘하면 된다. 그것이 함수의 목적인 재사용성을 높일 수있는 방법이다.

누구나 이해할 수 있는 이름을 붙여라

클린코드나 리팩터링 등에서도 많이 언급되는 문제지만, 가능한 함수 이름은 간결하고 이해하기 쉽게 붙이는 것이 좋다.

사용하는 프로젝트의 프레임워크에 Terser가 설치돼 있다면 한글로 네이밍하는것도 좋은 방법이 될 수 있다. Terser는 자바스크립트 코드를 맹글링(코드를 컴파일러가 이해할 수있는 수준에서 단순화) 및 압축하는 도구다.

https://try.terser.org/ 를 방문해서 테스트 해 볼 수 있다.

실재 개발 단의 코드 크기나 번들링 속도에 있어서는 약간의 부담이 될 수 있지만 실제 서비스되는 코드에는 영향을 미치지 않고, 또 무엇보다 한글이 편한 한국 개발자들에게 함수나 변수 네이밍에 있어 자유를 줄 수 있다.

### 정리

지금까지 자바스크립트의 함수에 대해 간단하게 살펴봤다. 그러나 앞서 이야기한 것처럼 생각보다 함수를 완벽하게 이해하기 위해서는 알아둬야 할 것이 많고, 또 다양한 예외들이 있으므로 이에 대해 잘 알아둬야 한다.
